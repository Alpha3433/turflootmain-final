"use strict";exports.id=879,exports.ids=[879],exports.modules={90879:(t,e,a)=>{a.d(e,{W:()=>d});var r=a(38013);let i=null,n=null;async function o(){if(n)return n;try{return i||(i=new r.MongoClient(process.env.MONGO_URL,{serverSelectionTimeoutMS:5e3,connectTimeoutMS:1e4,maxPoolSize:20}),await i.connect()),n=i.db(process.env.DB_NAME||"turfloot_db")}catch(t){throw console.error("❌ Database connection error:",t),t}}class s{static emit(t,e,a){console.log(`🎉 Party socket emit to ${t}: ${e}`,a)}static emitToParty(t,e,a){console.log(`🎉 Party socket emit to party ${t}: ${e}`,a)}}class d{static async initializeCollections(){let t=await o();await t.collection("parties").createIndex({id:1},{unique:!0}),await t.collection("parties").createIndex({ownerId:1}),await t.collection("parties").createIndex({status:1}),await t.collection("party_invitations").createIndex({partyId:1,toUserId:1},{unique:!0}),await t.collection("party_invitations").createIndex({toUserId:1,status:1}),await t.collection("party_members").createIndex({partyId:1,userId:1},{unique:!0}),console.log("✅ Party system collections initialized")}static async createParty(t,e,a=null){let r=await o();if(!t||!e)throw Error("ownerId and ownerUsername are required");let i=await r.collection("party_members").findOne({userId:t,status:"joined"},{sort:{joinedAt:-1}});if(i){let t=await r.collection("parties").findOne({id:i.partyId,status:{$in:["active","waiting"]}});if(t)throw Error(`You already have an active party: "${t.name}". Leave your current party first.`);await r.collection("party_members").updateOne({_id:i._id},{$set:{status:"stale",updatedAt:new Date().toISOString()}})}let n=`party_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,s={id:n,ownerId:t,ownerUsername:e,name:a||`${e}'s Party`,status:"waiting",maxMembers:2,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};await r.collection("parties").insertOne(s);let d={id:`member_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,partyId:n,userId:t,username:e,role:"owner",status:"joined",joinedAt:new Date().toISOString()};return await r.collection("party_members").insertOne(d),console.log(`🎉 Party created: ${n} by ${e} (Max: 2 players)`),{success:!0,partyId:n,party:s}}static async inviteFriend(t,e,a,r){let i=await o(),n=await i.collection("parties").findOne({id:t,status:"waiting"});if(!n)throw Error("Party not found or not accepting invites");let d=await i.collection("party_members").findOne({partyId:t,userId:e,status:"joined"});if(!d)throw Error("You must be a member of this party to invite others");let[c,l]=await Promise.all([i.collection("party_invitations").findOne({partyId:t,toUserId:a,status:"pending"}),i.collection("party_members").findOne({partyId:t,userId:a})]);if(c)throw Error("User already has a pending invitation to this party");if(l)throw Error("User is already in this party");if(await i.collection("party_members").countDocuments({partyId:t,status:"joined"})>=n.maxMembers)throw Error("Party is full");let m=`invite_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,u={id:m,partyId:t,partyName:n.name,fromUserId:e,fromUsername:d.username,toUserId:a,toUsername:r,status:"pending",createdAt:new Date().toISOString(),expiresAt:new Date(Date.now()+6e5).toISOString()};return await i.collection("party_invitations").insertOne(u),s.emit(a,"party_invitation_received",{invitationId:m,partyId:t,partyName:n.name,fromUserId:e,fromUsername:d.username,expiresAt:u.expiresAt}),console.log(`🎉 Party invitation sent: ${e} → ${a} for party ${t}`),{success:!0,invitationId:m}}static async acceptInvitation(t,e){let a=await o(),r=await a.collection("party_invitations").findOne({id:t,toUserId:e,status:"pending"});if(!r)throw Error("Invitation not found or already processed");if(new Date(r.expiresAt)<new Date)throw await a.collection("party_invitations").updateOne({id:t},{$set:{status:"expired",updatedAt:new Date().toISOString()}}),Error("Invitation has expired");let i=await a.collection("parties").findOne({id:r.partyId,status:{$in:["waiting","active"]}});if(!i)throw Error("Party no longer exists or is not available");if(await a.collection("party_members").countDocuments({partyId:r.partyId,status:"joined"})>=i.maxMembers)throw Error("Party is now full");await this.leaveAllParties(e),await a.collection("party_invitations").updateOne({id:t},{$set:{status:"accepted",acceptedAt:new Date().toISOString(),updatedAt:new Date().toISOString()}});let n={id:`member_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,partyId:r.partyId,userId:e,username:r.toUsername,role:"member",status:"joined",joinedAt:new Date().toISOString()};await a.collection("party_members").insertOne(n);let d=await a.collection("party_members").find({partyId:r.partyId,status:"joined"}).toArray();return s.emitToParty(r.partyId,"member_joined",{userId:e,username:r.toUsername,partyId:r.partyId,memberCount:d.length}),s.emit(i.ownerId,"party_member_joined",{userId:e,username:r.toUsername,partyId:r.partyId,partyName:i.name}),console.log(`🎉 User joined party: ${e} → ${r.partyId}`),{success:!0,partyId:r.partyId,memberCount:d.length}}static async declineInvitation(t,e){let a=await o();if(0===(await a.collection("party_invitations").updateOne({id:t,toUserId:e,status:"pending"},{$set:{status:"declined",declinedAt:new Date().toISOString(),updatedAt:new Date().toISOString()}})).matchedCount)throw Error("Invitation not found or already processed");let r=await a.collection("party_invitations").findOne({id:t});return s.emit(r.fromUserId,"party_invitation_declined",{userId:e,username:r.toUsername,partyId:r.partyId}),console.log(`❌ Party invitation declined: ${t}`),{success:!0}}static async getUserParty(t){let e=await o(),a=await e.collection("party_members").findOne({userId:t,status:"joined"},{sort:{joinedAt:-1}});if(!a)return null;let r=await e.collection("parties").findOne({id:a.partyId,status:{$in:["waiting","active","in_game"]}});if(!r){await e.collection("party_members").updateOne({_id:a._id},{$set:{status:"stale",updatedAt:new Date().toISOString()}});let r=await e.collection("party_members").findOne({userId:t,status:"joined",_id:{$ne:a._id}},{sort:{joinedAt:-1}});if(r){let t=await e.collection("parties").findOne({id:r.partyId,status:{$in:["waiting","active","in_game"]}});if(t){let a=await e.collection("party_members").find({partyId:t.id,status:"joined"}).sort({joinedAt:1}).toArray();return{...t,members:a.map(t=>({id:t.userId,username:t.username,role:t.role,joinedAt:t.joinedAt})),memberCount:a.length,userRole:r.role}}}return null}let i=await e.collection("party_members").find({partyId:r.id,status:"joined"}).sort({joinedAt:1}).toArray();return{...r,members:i.map(t=>({id:t.userId,username:t.username,role:t.role,joinedAt:t.joinedAt})),memberCount:i.length,userRole:a.role}}static async leaveParty(t,e){let a=await o(),r=await a.collection("party_members").findOne({partyId:t,userId:e,status:"joined"});if(!r)throw Error("You are not a member of this party");return(await a.collection("party_members").updateOne({partyId:t,userId:e},{$set:{status:"left",leftAt:new Date().toISOString()}}),"owner"===r.role)?(await this.disbandParty(t),{success:!0,disbanded:!0}):(s.emitToParty(t,"member_left",{userId:e,username:r.username,partyId:t}),console.log(`👋 User left party: ${e} → ${t}`),{success:!0,disbanded:!1})}static async leaveAllParties(t){let e=await o();for(let a of(await e.collection("party_members").find({userId:t,status:"joined"}).toArray()))await this.leaveParty(a.partyId,t)}static async disbandParty(t){let e=await o(),[a,r]=await Promise.all([e.collection("parties").findOne({id:t}),e.collection("party_members").find({partyId:t,status:"joined"}).toArray()]);if(!a)throw Error("Party not found");return await e.collection("parties").updateOne({id:t},{$set:{status:"disbanded",disbandedAt:new Date().toISOString(),updatedAt:new Date().toISOString()}}),await e.collection("party_members").updateMany({partyId:t},{$set:{status:"disbanded",leftAt:new Date().toISOString()}}),await e.collection("party_invitations").updateMany({partyId:t,status:"pending"},{$set:{status:"cancelled",updatedAt:new Date().toISOString()}}),r.forEach(e=>{s.emit(e.userId,"party_disbanded",{partyId:t,partyName:a.name,reason:"Party owner disbanded the party"})}),console.log(`💀 Party disbanded: ${t}`),{success:!0}}static async getPendingInvitations(t){let e=await o();return(await e.collection("party_invitations").find({toUserId:t,status:"pending",expiresAt:{$gt:new Date().toISOString()}}).sort({createdAt:-1}).toArray()).map(t=>({id:t.id,partyId:t.partyId,partyName:t.partyName,fromUserId:t.fromUserId,fromUsername:t.fromUsername,toUserId:t.toUserId,toUsername:t.toUsername,createdAt:t.createdAt,expiresAt:t.expiresAt}))}static async getInvitableFriends(t,e){let a=await o(),r=await a.collection("friendships").find({$or:[{fromUserId:t,status:"active"},{toUserId:t,status:"active"}]}).toArray(),i=r.map(e=>e.fromUserId===t?e.toUserId:e.fromUserId);if(0===i.length)return[];let[n,s]=await Promise.all([a.collection("party_members").find({userId:{$in:i},status:"joined"}).toArray(),a.collection("party_invitations").find({toUserId:{$in:i},status:"pending"}).toArray()]),d=new Set([...n.map(t=>t.userId),...s.map(t=>t.toUserId)]),c=[];for(let e of r){let a=e.fromUserId===t?e.toUserId:e.fromUserId,r=e.fromUserId===t?e.toUsername:e.fromUsername;d.has(a)||c.push({id:a,username:r})}return c}static async startPartyGame(t,e,a=0,r){let i=await o();try{let n=await i.collection("parties").findOne({id:t,ownerId:r,status:"waiting"});if(!n)return{success:!1,error:"Party not found or you are not the owner"};let o=await i.collection("party_members").find({partyId:t,status:"joined"}).toArray();if(o.length<2||o.length>2)return{success:!1,error:`Invalid party size: ${o.length}. Must be exactly 2 members.`};let s=`game_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,d={id:s,partyId:t,roomType:e,entryFee:a,maxPlayers:2,currentPlayers:0,status:"waiting_for_players",members:o.map(t=>({userId:t.userId,username:t.username,status:"invited"})),createdAt:new Date().toISOString(),expiresAt:new Date(Date.now()+3e5).toISOString()};await i.collection("game_rooms").insertOne(d),await i.collection("parties").updateOne({id:t},{$set:{status:"in_game",gameRoomId:s,gameStartedAt:new Date().toISOString()}});let c=o.filter(t=>t.userId!==r).map(r=>({id:`notify_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,userId:r.userId,type:"party_game_start",title:"Party Game Starting!",message:`${n.ownerUsername} started a ${e} game. Click to join!`,data:{gameRoomId:s,partyId:t,roomType:e,entryFee:a,partyMembers:o},status:"pending",createdAt:new Date().toISOString(),expiresAt:new Date(Date.now()+12e4).toISOString()}));return c.length>0&&(await i.collection("party_notifications").insertMany(c),console.log(`📢 Created ${c.length} party game notifications`)),console.log(`🎮 Party game started: ${s} for party ${t} (${e}, $${a})`),console.log(`👥 Party members: ${o.map(t=>t.username).join(", ")}`),{success:!0,gameRoomId:s,partyMembers:o,roomType:e,entryFee:a,notificationsCreated:c.length}}catch(t){return console.error("❌ Error starting party game:",t),{success:!1,error:"Failed to start party game"}}}static async getPartyNotifications(t){let e=await o();try{let a=await e.collection("party_notifications").find({userId:t,status:{$in:["pending","seen"]},expiresAt:{$gt:new Date().toISOString()}}).sort({createdAt:-1}).limit(10).toArray();return console.log(`📢 Retrieved ${a.length} notifications for user ${t}`),{success:!0,notifications:a,count:a.length}}catch(t){return console.error("❌ Error getting party notifications:",t),{success:!1,error:"Failed to get notifications",notifications:[],count:0}}}static async markNotificationSeen(t,e){let a=await o();try{if((await a.collection("party_notifications").updateOne({id:t,userId:e},{$set:{status:"seen",seenAt:new Date().toISOString()}})).matchedCount>0)return console.log(`👀 Notification ${t} marked as seen by ${e}`),{success:!0};return{success:!1,error:"Notification not found or not owned by user"}}catch(t){return console.error("❌ Error marking notification as seen:",t),{success:!1,error:"Failed to mark notification as seen"}}}}}};