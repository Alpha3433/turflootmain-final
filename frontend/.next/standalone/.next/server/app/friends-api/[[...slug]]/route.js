"use strict";(()=>{var e={};e.id=4058,e.ids=[4058],e.modules={38013:e=>{e.exports=require("mongodb")},20399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},51084:(e,t,s)=>{s.r(t),s.d(t,{originalPathname:()=>k,patchFetch:()=>y,requestAsyncStorage:()=>R,routeModule:()=>O,serverHooks:()=>D,staticGenerationAsyncStorage:()=>x});var r={};s.r(r),s.d(r,{GET:()=>S,OPTIONS:()=>h,POST:()=>q});var n=s(49303),o=s(88716),i=s(60670),a=s(87070),d=s(38013);let l=null,c=null;async function u(){if(c)return c;try{return l||(l=new d.MongoClient(process.env.MONGO_URL,{serverSelectionTimeoutMS:5e3,connectTimeoutMS:1e4,maxPoolSize:20}),await l.connect()),c=l.db(process.env.DB_NAME||"turfloot_db")}catch(e){throw console.error("❌ Database connection error:",e),e}}class m{constructor(){this.presenceSet=new Map,this.suggestionsCache=new Map,this.rateLimitCache=new Map}setUserOnline(e){this.presenceSet.set(e,{online:!0,lastSeen:Date.now()}),console.log(`🟢 User ${e} is now online`)}setUserOffline(e){let t=this.presenceSet.get(e)||{};this.presenceSet.set(e,{...t,online:!1,lastSeen:Date.now()}),console.log(`🔴 User ${e} is now offline`)}isUserOnline(e){let t=this.presenceSet.get(e);return t?.online||!1}getOnlineUsers(){let e=[];for(let[t,s]of this.presenceSet.entries())s.online&&e.push(t);return e}setSuggestions(e,t){this.suggestionsCache.set(e,t),setTimeout(()=>{this.suggestionsCache.delete(e)},3e5)}getSuggestions(e){return this.suggestionsCache.get(e)||null}checkRateLimit(e){let t=Date.now(),s=this.rateLimitCache.get(e);return!s||t>s.resetTime?(this.rateLimitCache.set(e,{count:1,resetTime:t+36e5}),{allowed:!0,remaining:9}):s.count>=10?{allowed:!1,remaining:0,resetIn:s.resetTime-t}:(s.count++,{allowed:!0,remaining:10-s.count})}}let f=new m;class g{static emit(e,t,s){console.log(`🔌 Socket emit to ${e}: ${t}`,s)}static emitToMultiple(e,t,s){e.forEach(e=>{this.emit(e,t,s)})}}class p{static async initializeCollections(){let e=await u();await e.collection("friendships").createIndex({fromUserId:1,toUserId:1},{unique:!0}),await e.collection("friendships").createIndex({toUserId:1,status:1}),await e.collection("friend_requests").createIndex({fromUserId:1,toUserId:1},{unique:!0}),await e.collection("friend_requests").createIndex({toUserId:1,status:1}),await e.collection("blocked_users").createIndex({blockerId:1,blockedId:1},{unique:!0}),await e.collection("users").createIndex({username:1}),console.log("✅ Friends system collections initialized")}static async sendFriendRequest(e,t,s,r){let n=await u();if(!e||!t)throw Error("fromUserId and toUserId are required");if(e===t)throw Error("Cannot send friend request to yourself");let o=f.checkRateLimit(e);if(!o.allowed){let e=Error("Rate limit exceeded. Too many friend requests.");throw e.code=429,e.resetIn=o.resetIn,e}if(await n.collection("blocked_users").findOne({$or:[{blockerId:e,blockedId:t},{blockerId:t,blockedId:e}]}))throw Error("Cannot send friend request to blocked user");if(await n.collection("friendships").findOne({$or:[{fromUserId:e,toUserId:t},{fromUserId:t,toUserId:e}]}))throw Error("Users are already friends");if(await n.collection("friend_requests").findOne({$or:[{fromUserId:e,toUserId:t,status:"pending"},{fromUserId:t,toUserId:e,status:"pending"}]}))throw Error("Friend request already pending");let i=`req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,a={id:i,fromUserId:e,toUserId:t,fromUsername:s||"Unknown",toUsername:r||"Unknown",status:"pending",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await n.collection("friend_requests").insertOne(a),g.emit(t,"friend_request_incoming",{requestId:i,fromUserId:e,fromUsername:a.fromUsername}),console.log(`✅ Friend request sent: ${e} → ${t}`),{success:!0,requestId:i,remaining:o.remaining}}static async acceptFriendRequest(e,t){let s=await u(),r=await s.collection("friend_requests").findOne({id:e,toUserId:t,status:"pending"});if(!r)throw Error("Friend request not found or already processed");let n=`friendship_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,o={id:n,fromUserId:r.fromUserId,toUserId:r.toUserId,fromUsername:r.fromUsername,toUsername:r.toUsername,status:"active",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await s.collection("friendships").insertOne(o),await s.collection("friend_requests").updateOne({id:e},{$set:{status:"accepted",updatedAt:new Date().toISOString()}}),await s.collection("friend_requests").updateMany({fromUserId:r.toUserId,toUserId:r.fromUserId,status:"pending"},{$set:{status:"auto_closed",updatedAt:new Date().toISOString()}}),g.emit(r.fromUserId,"friend_request_accepted",{userId:r.toUserId,username:r.toUsername}),g.emit(r.toUserId,"friend_added",{userId:r.fromUserId,username:r.fromUsername}),console.log(`✅ Friend request accepted: ${r.fromUserId} ↔ ${r.toUserId}`),{success:!0,friendshipId:n}}static async declineFriendRequest(e,t){let s=await u();if(0===(await s.collection("friend_requests").updateOne({id:e,toUserId:t,status:"pending"},{$set:{status:"declined",updatedAt:new Date().toISOString()}})).matchedCount)throw Error("Friend request not found or already processed");let r=await s.collection("friend_requests").findOne({id:e});return g.emit(r.fromUserId,"friend_request_declined",{userId:r.toUserId,username:r.toUsername}),console.log(`❌ Friend request declined: ${e}`),{success:!0}}static async blockUser(e,t,s,r){let n=await u();if(e===t)throw Error("Cannot block yourself");await n.collection("friendships").deleteMany({$or:[{fromUserId:e,toUserId:t},{fromUserId:t,toUserId:e}]}),await n.collection("friend_requests").updateMany({$or:[{fromUserId:e,toUserId:t},{fromUserId:t,toUserId:e}],status:"pending"},{$set:{status:"cancelled",updatedAt:new Date().toISOString()}});let o=`block_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;return await n.collection("blocked_users").insertOne({id:o,blockerId:e,blockedId:t,blockerUsername:s||"Unknown",blockedUsername:r||"Unknown",createdAt:new Date().toISOString()}),g.emit(t,"user_blocked_you",{userId:e,username:s}),g.emit(e,"user_blocked",{userId:t,username:r}),console.log(`🚫 User blocked: ${e} blocked ${t}`),{success:!0,blockId:o}}static async getFriendsList(e){let t=await u();return(await t.collection("friendships").find({$or:[{fromUserId:e},{toUserId:e}],status:"active"}).toArray()).map(t=>{let s=t.fromUserId===e?t.toUserId:t.fromUserId;return{id:s,username:t.fromUserId===e?t.toUsername:t.fromUsername,online:f.isUserOnline(s),lastSeen:t.updatedAt,friendshipId:t.id}})}static async searchUsers(e,t,s=!1,r=!1){let n=await u();if(!r&&(!e||e.length<2))return[];let[o,i,a]=await Promise.all([n.collection("friendships").find({$or:[{fromUserId:t},{toUserId:t}],status:"active"}).toArray(),n.collection("blocked_users").find({$or:[{blockerId:t},{blockedId:t}]}).toArray(),n.collection("friend_requests").find({$or:[{fromUserId:t,status:"pending"},{toUserId:t,status:"pending"}]}).toArray()]),d=new Set([t]);o.forEach(e=>{d.add(e.fromUserId===t?e.toUserId:e.fromUserId)}),i.forEach(e=>{d.add(e.blockerId===t?e.blockedId:e.blockerId)}),a.forEach(e=>{d.add(e.fromUserId===t?e.toUserId:e.fromUserId)});let l={id:{$nin:Array.from(d)}};e&&e.length>0&&(l.username={$regex:e,$options:"i"});let c=await n.collection("users").find(l).limit(20).toArray();return s&&(c=c.filter(e=>f.isUserOnline(e.id))),c.map(e=>({id:e.id,username:e.username,online:f.isUserOnline(e.id),canSendRequest:!0}))}static async getFriendSuggestions(e,t=10){let s=f.getSuggestions(e);if(s)return console.log("\uD83D\uDCE6 Returning cached suggestions"),s;let r=await u(),n=await r.collection("users").aggregate([{$match:{id:{$ne:e}}},{$sample:{size:2*t}}]).toArray(),o=await this.searchUsers("",e),i=new Set(n.map(e=>e.id)),a=o.filter(e=>i.has(e.id)).slice(0,t);return f.setSuggestions(e,a),a}static async getPendingRequests(e){let t=await u();return(await t.collection("friend_requests").find({toUserId:e,status:"pending"}).sort({createdAt:-1}).toArray()).map(e=>({id:e.id,fromUserId:e.fromUserId,fromUsername:e.fromUsername,createdAt:e.createdAt}))}static setUserOnline(e){f.setUserOnline(e),g.emit(e,"presence_updated",{online:!0})}static setUserOffline(e){f.setUserOffline(e),g.emit(e,"presence_updated",{online:!1})}static getOnlineUsers(){return f.getOnlineUsers()}}let I={"Access-Control-Allow-Origin":"*","Access-Control-Allow-Methods":"GET, POST, PUT, DELETE, OPTIONS","Access-Control-Allow-Headers":"Content-Type, Authorization, X-Requested-With, Accept, Origin","Cache-Control":"no-store, no-cache, must-revalidate","X-API-Server":"TurfLoot-FriendsAPI-Advanced"};async function h(){return new a.NextResponse(null,{status:200,headers:I})}let w=!1;async function U(){w||(await p.initializeCollections(),w=!0)}async function S(e,{params:t}){await U();let{slug:s}=t,r=new URL(e.url);console.log("\uD83E\uDD1D FRIENDS-API GET:",s,r.searchParams.toString());try{let e=s[0]||"list",t=r.searchParams.get("userId");if(!t)return a.NextResponse.json({error:"userId required"},{status:400,headers:I});if("list"===e){let e=await p.getFriendsList(t);return a.NextResponse.json({friends:e,timestamp:new Date().toISOString()},{headers:I})}if("pending-requests"===e){let e=await p.getPendingRequests(t);return a.NextResponse.json({requests:e,count:e.length,timestamp:new Date().toISOString()},{headers:I})}if("suggestions"===e){let e=parseInt(r.searchParams.get("limit"))||10,s=await p.getFriendSuggestions(t,e);return a.NextResponse.json({suggestions:s,count:s.length,timestamp:new Date().toISOString()},{headers:I})}if("search"===e){let e=r.searchParams.get("q")||"",s="true"===r.searchParams.get("onlineOnly"),n="true"===r.searchParams.get("showAll");if(!n&&e.length<2)return a.NextResponse.json({users:[],message:"Query must be at least 2 characters"},{headers:I});let o=await p.searchUsers(n?"":e,t,s,n);return a.NextResponse.json({users:o,total:o.length,query:e,onlineOnly:s,showAll:n,timestamp:new Date().toISOString()},{headers:I})}if("online-status"===e){let e=await p.getFriendsList(t),s=e.filter(e=>e.online);return a.NextResponse.json({onlineFriends:s,totalFriends:e.length,onlineCount:s.length,timestamp:new Date().toISOString()},{headers:I})}return a.NextResponse.json({error:"Invalid action"},{status:400,headers:I})}catch(e){return console.error("❌ Friends API GET error:",e),a.NextResponse.json({error:e.message||"Internal error",code:e.code||500},{status:e.code||500,headers:I})}}async function q(e,{params:t}){await U();let{slug:s}=t;console.log("\uD83E\uDD1D FRIENDS-API POST:",s);try{let t=await e.json(),r=s[0]||"send-request";if("send-request"===r){let{fromUserId:e,toUserId:s,fromUsername:r,toUsername:n}=t;if(!e||!s)return a.NextResponse.json({error:"fromUserId and toUserId required"},{status:400,headers:I});let o=await p.sendFriendRequest(e,s,r,n);return a.NextResponse.json({success:!0,message:"Friend request sent successfully",requestId:o.requestId,remaining:o.remaining,timestamp:new Date().toISOString()},{headers:I})}if("accept-request"===r){let{requestId:e,userId:s}=t;if(!e||!s)return a.NextResponse.json({error:"requestId and userId required"},{status:400,headers:I});let r=await p.acceptFriendRequest(e,s);return a.NextResponse.json({success:!0,message:"Friend request accepted",friendshipId:r.friendshipId,timestamp:new Date().toISOString()},{headers:I})}if("decline-request"===r){let{requestId:e,userId:s}=t;if(!e||!s)return a.NextResponse.json({error:"requestId and userId required"},{status:400,headers:I});return await p.declineFriendRequest(e,s),a.NextResponse.json({success:!0,message:"Friend request declined",timestamp:new Date().toISOString()},{headers:I})}if("block-user"===r){let{blockerId:e,blockedId:s,blockerUsername:r,blockedUsername:n}=t;if(!e||!s)return a.NextResponse.json({error:"blockerId and blockedId required"},{status:400,headers:I});let o=await p.blockUser(e,s,r,n);return a.NextResponse.json({success:!0,message:"User blocked successfully",blockId:o.blockId,timestamp:new Date().toISOString()},{headers:I})}if("presence"===r){let e=s[1]||"online",{userId:r}=t;if(!r)return a.NextResponse.json({error:"userId required"},{status:400,headers:I});if("online"===e)return p.setUserOnline(r),a.NextResponse.json({success:!0,message:"User set as online",timestamp:new Date().toISOString()},{headers:I});if("offline"===e)return p.setUserOffline(r),a.NextResponse.json({success:!0,message:"User set as offline",timestamp:new Date().toISOString()},{headers:I})}if("notifications"===r){let e=s[1]||"count";if("count"===e){let{userId:e}=t;if(!e)return a.NextResponse.json({error:"userId required"},{status:400,headers:I});let s=await p.getPendingRequests(e);return a.NextResponse.json({count:s.length,timestamp:new Date().toISOString()},{headers:I})}if("mark-read"===e)return a.NextResponse.json({success:!0,message:"Notifications marked as read",timestamp:new Date().toISOString()},{headers:I})}return a.NextResponse.json({error:"Invalid action"},{status:400,headers:I})}catch(e){if(console.error("❌ Friends API POST error:",e),429===e.code)return a.NextResponse.json({error:e.message,code:429,resetIn:e.resetIn,timestamp:new Date().toISOString()},{status:429,headers:I});return a.NextResponse.json({error:e.message||"Failed to process request",timestamp:new Date().toISOString()},{status:500,headers:I})}}let O=new n.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/friends-api/[[...slug]]/route",pathname:"/friends-api/[[...slug]]",filename:"route",bundlePath:"app/friends-api/[[...slug]]/route"},resolvedPagePath:"/app/frontend/app/friends-api/[[...slug]]/route.js",nextConfigOutput:"standalone",userland:r}),{requestAsyncStorage:R,staticGenerationAsyncStorage:x,serverHooks:D}=O,k="/friends-api/[[...slug]]/route";function y(){return(0,i.patchFetch)({serverHooks:D,staticGenerationAsyncStorage:x})}}};var t=require("../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),r=t.X(0,[8948,5972],()=>s(51084));module.exports=r})();